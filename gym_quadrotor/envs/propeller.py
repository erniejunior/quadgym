# Aerodynamics of a single propeller. See Martin, Salaun> The True Role of Accelerometer Feedback in Quadrotor Control

import numpy as np
from .geo import *

class Propeller(object):
    def __init__(self, a, b, lm, mu, d, p, axis):
        self._a = a
        self._b = b
        self._lambdas   = lm
        self._mus       = mu
        self._direction = d
        self._position  = p
        self._axis      = axis

    @property
    def a(self): return self._a

    @property
    def b(self): return self._b

    @property
    def lambdas(self): return self._lambdas

    @property
    def mus(self): return self._mus

    @property
    def direction(self): return self._direction

    @property
    def position(self):
        return self._position

    @property
    def axis(self):
        return self._axis

    def get_dynamics(self, speed, copter_status):
        """ Gets the dynamics (force, moment and moment around prop axis)
            generated by this propeller.
        """
        velocity = copter_status.velocity
        # convert axis from copter to world frame
        ang_vel  = copter_status.to_world_direction(copter_status.angular_velocity)
        axis     = copter_status.to_world_direction(self._axis)
        pos      = copter_status.to_world_direction(self._position)

        F        = force(self, speed, axis, velocity, ang_vel)
        M        = moment(self, speed, axis, velocity, ang_vel)
        # remove the part that accelerates the propeller
        ma       = np.dot(M, axis)
        M       -= ma * axis
        # and add what the force does through the lever.
        M       += np.cross(pos, F)
        return F, M, ma



def force(propeller, speed, axis, velocity, angular_velocity):
    """ Calculates the force action on the propeller with parameters
        given by `propeller` that revolves with angular velocity
        `speed` about `axis`. The rotor moves with velocity `velocity`
        and the axis rotates with `angular_velocity`. Everything is 
        assumed to be in world coordinates. 
    """
    # variable shorthands
    a  = propeller.a
    l1, l2, l3, l4 = propeller.lambdas
    e  = propeller.direction
    w  = speed
    Va = velocity
    O  = angular_velocity

    t1 = - a*w*w * axis
    t2 = w * (l1 * bot(Va, axis) - l2 * np.cross(O, axis) )
    t3 = e * w * (l3 * np.cross(Va, axis) - l4 * bot(O, axis))

    return t1 + t2 + t3

def moment(propeller, speed, axis, velocity, angular_velocity):
    """ Calculates the moment acting on a propeller with aerodynamic 
        parameters given by `propeller` that revolves with angular 
        velocity `speed` about `axis`. The rotor moves with 
        velocity `velocity` and its axis rotaties with `angular velocity`.
        Everything is supposed to be in world coordinates.
    """
    # variable shorthands
    b  = propeller.b
    u1, u2, u3, u4 = propeller.mus
    e  = propeller.direction
    w  = speed
    Va = velocity
    O  = angular_velocity

    t1 = -b * e * w * w * axis
    t2 = -w * (u1 * bot(Va, axis) + u2 * np.cross(O, axis))
    t3 = -e * w * (u3 * np.cross(Va, axis) + u4 * bot(O, axis))

    return t1 + t2 + t3

