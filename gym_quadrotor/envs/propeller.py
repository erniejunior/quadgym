# Aerodynamics of a single propeller. See Martin, Salaun> The True Role of Accelerometer Feedback in Quadrotor Control

import numpy as np
from .geo import *

class Propeller(object):
    def __init__(self, a, b, lm, mu, d, p, axis):
        self._a = a
        self._b = b
        self._lambdas   = lm
        self._mus       = mu
        self._direction = d
        self._position  = p
        self._axis      = axis

    @property
    def a(self): return self._a

    @property
    def b(self): return self._b

    @property
    def lambdas(self): return self._lambdas

    @property
    def mus(self): return self._mus

    @property
    def direction(self): return self._direction

    @property
    def position(self):
        return self._position

    def get_dynamics(self, speed, copter_status):
        """ Gets the dynamics (force, moment and moment around prop axis)
            generated by this propeller.
        """
        velocity = copter_status.velocity
        ang_vel  = copter_status.angular_velocity
        trafo    = copter_status.attitude
        trafo    = make_quaternion(trafo[0], trafo[1], trafo[2]).rotation_matrix
        # convert axis from copter to world frame
        axis     = np.dot(trafo, self._axis)
        pos      = np.dot(trafo, self._position)

        F        = force(self, speed, axis, velocity, ang_vel)
        M        = moment(self, speed, axis, velocity, ang_vel)
        ma       = np.dot(M, axis)
        M       += np.cross(pos, F)
        return F, M, ma



def force(propeller, speed, axis, velocity, angular_velocity):
    # variable shorthands
    a  = propeller.a
    l1, l2, l3, l4 = propeller.lambdas
    e  = propeller.direction
    w  = speed
    Va = velocity
    O  = angular_velocity

    t1 = - a*w*w * axis
    t2 = w * (l1 * bot(Va, axis) - l2 * np.cross(O, axis) )
    t3 = e * w * (l3 * np.cross(Va, axis) - l4 * bot(O, axis))

    return t1 + t2 + t3

def moment(propeller, speed, axis, velocity, angular_velocity):
    # variable shorthands
    b  = propeller.b
    u1, u2, u3, u4 = propeller.mus
    e  = propeller.direction
    w  = speed
    Va = velocity
    O  = angular_velocity

    t1 = -b * e * w * w * axis
    t2 = -w * (u1 * bot(Va, axis) + u2 * np.cross(O, axis))
    t3 = -e * w * (u3 * np.cross(Va, axis) + u4 * bot(O, axis))

    return t1 + t2 + t3

